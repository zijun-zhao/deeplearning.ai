
### This file will record all problems I have encountered during studying the course W4111 in 2020 Spring.
* Prof. Donald F. Ferguson's page for this course [GitHub home page](https://donald-f-ferguson.github.io/IntroToDatabases/)
* Prof. Donald F. Ferguson's [Repository/Project](https://github.com/donald-f-ferguson/IntroToDatabases)

### Table of Contents

1. [Lecture1&2-24Jan](https://github.com/zijun-zhao/fishLearning/blob/master/COMS4111/Lecture1&2_Intro&Overview.md)
2. [Lecture3-31Jan](https://github.com/zijun-zhao/fishLearning/blob/master/COMS4111/Lecture3.md)
3. [Lecture4-7Feb](#my-second-title)
4. [Lecture5-14Feb](#my-second-title)
5. [Lecture6-21Feb](#my-second-title)

## 8 Feb 2020
----------
1. When designing a database from logical to physical model, a lot is needed to consider.
	* An associate entity
		* Aims to relate other entites. A row in that table represents a line between a specific student and a specific section. Each row represents the connection between two instances. If not having this associate table, we may lose information. For instance, if a student changes his advisor, then we need another attribute in the associate relation table to record the start_data he chose one advisor.
	* Corner condition met when implementing in physical model
	```sql
	CREATE TABLE 'Course'(
	'dept_code' char(4) NOT NULL,
	'faculty_code' enum('W','E','C','G','B') NOT NULL,
	'level' enum('0','1','2','3','4','6','9') NOT NULL,
	'number' char(3) NOT NULL,
	'site' varchar(12) NOT NULL,
	'course_no' varchar(12) GENERATED ALWAYS AS (concat('dep_code','faculty_code','level','number'))STORED,
	PRIMARY KEY ('dept_code','faculty_code','level','number'),
	UNIQUE KEY 'course_no_UNIQUE'('course_no')
	)ENGINE=innoDB DEFAULT CHARSET=ut8mb4 COLLATE=ut8mb4_0900_ai_ci;
	```
		* Note here we cannot set the course_no since it is generated by others and we store it, which is a *generation statement*. After storing, we can represent as a foreign key to represent it. We need to speicify in the SQL workbench.
		
2. Primary key is **unique** for the table it is defined as primary key.	

3. **A strength of the relational model: integrity rules are inextricably attached to the data**. The database engine has got the data that allows you to run a fixed set of operation against it and it get a set of integrity constrains, computer readable descriptions of the data,
	* Example operates to columns: not null is an example, default is also an example. In relational model, integrity is inherent part of the model
	* Example operates to table level: key is an example. Like uni need to be unqiue. In relational theory key is what most people cares about. 
		* For the student entity, it has uni and email. Email has to be unique, so as the uni. If you have a table of people and you change the email, it is still the same person. For *primary key, we need something immutablae*. uni is an  immutable property.
		
4. For each entry, there are 
	* "atomic": number of string
	* "multi-valued": lists or dictionaries. For example, the one-to-many relation between episode and location

5. In the example used in class, type "scenes" can be a list of things, including sceneStart, location, sublocation, character. In addition to the entity the episode, there is an entity type 'scene' which has not on a separate file, scenes are *contained* in the episodes.json file. When two entities are related, there are many ways to think about **one-to-many, many-to-one, required or contained**. In university, faculty and student are all instances of person. If two entities are not isa, we need to ask is it sort of containment. If we delete a scene, the character is not contained in that scene, it is just referred to. But throw away an episode, the scenes are also deleted. There is a one-to-many relationship between episode and scene. One episode has one or more scenes. A scene is linked to exactly one location. And note there exists certain locations that does not shown in scene, like people talked about it but never shows it.
	* If a table is contained in something, you require to have a container. But you could have acquired relationships that are not containment, and so these are the ways you need to think about during physical model.

6. What is the difference between references and contains:
	* Contains: **weak entity**
	> "In a relational database, a weak entity is an entity that *cannot be uniquely identified by its attributes alone*; therefore, it must **use a foreign key in conjunction with its attributes to create a primary key**. The foreign key is typically a primary key of an entity it is related to." For example, the prmary key of an episode is the season number+episode. We cant't make a key for scene without making a key for episode. We make a key value, you will always make a key in another table, it kinds of a part of it. The primary key for a scene is (seasonNumber, episodeNumber, sceneNumber). You cannot form the key without the properties of an episode.
	* What is an example of references that is not weak? 
		* Consider a banking account. Hypothetically, accountNumber is the primary key. customerID is a foreign key that links acount to customer.
		* On the other hand, the primary key for a scene is (seasonNumber, episodeNumber, sceneNumber), therefore we cannot form the key without the properties of an episode.

7. **Web Applications**
- Presentation tier
	* Topmost level of the application.
- Application tier(business logic, logic tier, ot middle tier)
- Data tier

	> The business logic and data access are often separate microservices.
	
	> There are usually many independent, interacting microservices in both layers.
	
	> Refer to Donald F. Ferguson's COMS6156
	![Web Application Layers/Microservices](https://donald-f-ferguson.github.io/w4111-Databases/images/webapp.jpeg)
	![Web Application Layers/Microservices](https://donald-f-ferguson.github.io/w4111-Databases/images/simple_aws_web_app.jpeg)



8. As to the integrity constraints in create table
	* Three fundamental ones: primary, foreign, not null
	* Except for primary key, foreign key, there are also 
		* check constrains, apply when insert and update. For example, check constrint 
		* default values
		* generated column values.
	
9. **Set** operation has three types: union, intersect and difference. Each of these operations automatically eliminate duplicates. To retain all duplicates need to use
	```sql
	union all
	intersect all
	except all
	```
	* According to Prof. Ferguson:
	> **Not all databases support all the set operation, there are workarounds using JOIN and UNION**

10. In relational theory, a relation is **a set** of tuples, we cannot have exactly the same tuple twice. The reason why a relation is a set is that they all have primary key, and a primary key is unique
	* In relational databases, that is not true. Relational database tables can have duplicates. The way you prevent duplicate is to define a primary key. **primary key is unique** so no two rows are exactly the same.
		* In relational databses, primary key is optional since **relational algebra is close under all the operators**, doing a select statement we do not need to pick all the columns. If my select statement doesn't pick the primary key column, we cannot guarantee the rows are unique in the resulted table.
		* Therefore derived table, are not sets in theory.

11. **view** looks like a table, but it will be calculated every time you view it.
## 12 Feb 2020
----------
1. Creat a new schema in sql workbench
	* Local instance->Right click in the left panel and choose Create Schema->
2. Usage of "like" in sql	
	* The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.

	* There are two wildcards often used in conjunction with the LIKE operator:
		* % - The percent sign represents **zero, one, or multiple** characters
		* _ - The underscore represents a **single** character
		* Find all the characters with last name Stark.
		```sql
		%sql select * from characters where characterName like("% Stark")
		```
		* Finds any values that begin with "a "
		```sql
		%sql select * from characters where characterName like("a % ")
		```
		* Finds any values that start with "a" and are at least 3 characters in length
		```sql
		WHERE CustomerName LIKE 'a__%'
		```	

## 14 Feb 2020
----------
1. describe in **sql**

2. Quotation mark '' when creating the table in **sql**
	```sql
	%%sql
	create table W4111GotSolutionClean.groups (
	    id int,
	    groupName varchar(32),
	    `characterName` varchar(32))
	```
	* As answered by Prof. Ferguson,
	> Backticks are used to **escape keywords, special characters, spaces, etc**. They're typically good practice and will help your 
	e be safer but aren't strictly necessary in every instance. That normally happens when people use MySQL Workbench to help with a DDL statement and then copy the statement into the notebook or code. **Backtick is only needed if the schema term has some weird character in it lie - or a space**, i.e. `Character Name`.

3. Dr. E. F. Codd's original 13 rules to determine if a DBMS can be considered a relational DBMS (RDBMS):
	> Often referred to as rule 0, this rule states that all subsequent rules are based on the notion that in order for a database to be considered relational, it must *use its relational facilities exclusively to manage the database*.
	> 1. The Information rule: All **information in an RDBMS** is represented logically in just one way - by **values in tables**.
	> 2. The Guaranteed Access rule: Each item of data in an RDBMS is guaranteed to be **logically accessible** by resorting to a combination of table name, primary key value, and column name.
	> 3. The Systematic Treatment of Null Values rule: Null values (distinct from an empty character string or a string of blank characters and distinct from zero or any other number) are **supported in a fully relational DBMS** for representing missing information and inapplicable information in a systematic way, *independent of the data type*.
	> 4. The Dynamic Online Catalog Based on the Relational Model rule: The database description is represented at the logical level in the same way as ordinary data, so that authorized users can apply the same relational language to its interrogation as they apply to the regular data.
	> 5. The Comprehensive Data Sublanguage rule: A relational system may support several languages and various modes of terminal use (for example, the fill-in-blanks mode). However, there must be at least one language whose statements are expressible, per some well-defined syntax, as character strings and whose ability to support all of the following is comprehensible: data definition, view definition, data manipulation (interactive and by program), integrity constraints, and transaction boundaries (begin, commit, and rollback).
	> 6. The View Updating rule: All views of the data which are theoretically updatable must be updatable in practice by the DBMS.
	> 7. The High-level Insert, Update, and Delete rule: The capability of handling a base relation or a derived relation as a single operand applies not only to the retrieval of data but also to the insertion, update, and deletion of data.
	> 8. The Physical Data Independence rule: Application programs and terminal activities remain logically unimpaired whenever any changes are made in either storage representations or access methods.
	> 9. The Logical Data Independence rule: Application programs and terminal activities remain logically unimpaired when information preserving changes of any kind that theoretically permit unimpairment are made to the base tables.
	> 10. The Integrity Independence rule: Integrity constraints must be definable in the RDBMS sub-language and stored in the system catalogue and not within individual application programs.
	> 11. The Distribution Independence rule: An RDBMS has distribution independence. Distribution independence implies that users should not have to be aware of whether a database is distributed.
	> 12. The Nonsubversion rule: If the database has any means of handling a single record at a time, that low-level language must not be able to subvert or avoid the integrity rules which are expressed in a higher-level language that handles multiple records at a time.
	
4. '' is a common way to represent **"unknown" or "not applicable"** in text data.
	* Codd's Rule no. 3 defines the systmatic treatment of unknown or not applicable data.
	* **NULL is not the same as ""**, to make Ed Codd happy, try to use
		```
		%sql update characters set actorName=Null where actorName = ""
		```
	
5. For Homework1-c's data cleanup part, for varchar column, just perform the following:
	```sql
	%sql update W4111GoTSolutionClean.groups set characterName=NULL where characterName=''
	```
	* But for integer column, no need to reset missing int values, since
	> The import would have failed if there was an invalid integer value for a column in a row. So do not need to worry about the value not being set.
	

## 15 Feb 2020
----------
1. How to show the column name of a given table in SQL?
```sql
select * from INFORMATION_SCHEMA.COLUMNS
where table_name = '[table name]'
```
Do we need to replace the INFORMATION_SCHEMA here?

2. Date is not varchar
	> Date is not equal to varchar in any sense. There are built-in functions for converting between text and dates/time and vice versa.
	
3. Common problem when doing data import:
	* Column with True/False value in the csv file cannot be input as type **int**, it can only be specified as text(For the sql workbench in windows, I cannot even modify the type when import using wizard). Otherwise the import will not be successful.

4. To check whether characterName is unique
	```
	SELECT characterName, count(*) as count FROM db.characters
		group by characterName order by count desc
	```
5. The **text** type in mysql is not good, which is equivalent to varchar(62000), which can be annoying. Even if the column is unique, we cannot index a field with type text, and we cannot make it a foreign key or primary key.

6. Trick for cleanup
	* Suggested by Prof. Ferguson, instead of trying to convert the existing table, just write a query that reshapes the table and then create a copy from the query.
		* In the homework example, we just convert the quote true to a boolean
		```
		%%sql 
		select id, characterName, characterLink,actorName, character_id,
		    if (royal='True',true,false) as royal, 
		    characterImageThumb, characterImageFull, nickname,
		    if (kingsguard='True',true,false) as kingsguard
		    from W4111GoTSolution.characters;
		```
7. Insert a name to a table and generate a new id according to previous id
	```sql
	insert into w4111gotsolution.characters(id,character_id,characterName)
		values(select max(id)+1 as next_id from w4111gotsolution.scenes_characters),
	    (select concat("CH_",max(id)+1)from w4111gotsolution.scenes_characters, 
	    "Bob")
	 ```
